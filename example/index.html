<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>SPA | JavaScript</title>
    </head>
    <body>
        <a href="/">Home</a>
        <a href="/products">Products</a>
        <a href="/products/1">Product</a>
        <a href="/blog">Blog</a>

        <a href="https://github.com/ArefShojaei/Lite-PHP" data-link>Github</a>

        <div id="root"></div>

        <script>
class InvalidArgumentTypeError extends Error {
    constructor(message) {
        super(message)
        this.name = "Invalid argument error"
    }
}

class Element {
    constructor() {
        throw new Error(`${new.target.name} class must not be called with \"new\" keyword!`)
    }

    /**
     * @param {HTMLElement} element 
     * @param {function} callback 
     */
    static onClick(element, callback) {
        if (!(element instanceof HTMLElement)) throw new InvalidArgumentTypeError("'element' must be an HTMLElement!")

        if (typeof callback !== "function") throw new InvalidArgumentTypeError("'callback' must be a function!")

        
        element.addEventListener("click", callback)
    }
}

class Selector {
    static #elements = []


    constructor() {
        throw new Error(`${new.target.name} class must not be called with \"new\" keyword!`)
    }

    /**
     * @param {HTMLAnchorElement} element 
     * @param {Document} document 
     * @returns {Selector}
     */
    static findAll(element, document) {
        if (typeof element !== "string") throw new InvalidArgumentTypeError("'element' must be an HTMLElement object!")

        if (!(document instanceof Document)) throw new InvalidArgumentTypeError("'document' must be a Document object!")


        const elements = document.querySelectorAll(element)
        
        this._setElements(elements)

        return this
    }

    /**
     * @param {function} callback
     * @returns {void}
     */
    static each(callback) {
        if (!this.#elements.length) throw new Error("Can not use it before selecting elements!")

        if (typeof callback !== "function") throw new InvalidArgumentTypeError("'callback' must be a function!")


        const elements = this._getElements()

        elements.forEach(callback)
    }

    /**
     * @param {array} elements 
     */
    static _setElements(elements) {
        this.#elements.push(...elements)
    }

    /**
     * @returns {array}
     */
    static _getElements() {
        return this.#elements
    }
}

class Page {
    /**
     * Default page title
     */
    static #root = ""
    
    /**
     * Updated page title
     */
    static #title = ""
    

    static #document


    constructor() {
        throw new Error(`${new.target.name} class must not be called with \"new\" keyword!`)
    }

    /**
     * @param {Document} document 
     */
    static setDocument(document) {
        if (!(document instanceof Document)) throw new InvalidArgumentTypeError("'document' must be a Document object!")

        this.#document = document
    }
    
    /**
     * @returns {Document} 
     */
    static _getDocument() {
        return this.#document
    }

    /**
     * @param {string} value
     * @returns {void}
     */
    static setTitle(value) {
        if (typeof value !== "string") throw new InvalidArgumentTypeError("'title' must be a string!")


        this.#title = value

        this.#updateTitle()
    }

    /**
     * @param {string} value 
     * @returns {void}
     */
    static setRootTitle(value) {
        if (typeof value !== "string") throw new InvalidArgumentTypeError("'value' must be a string!")

        
        this.#root = value

        this.#updateTitle()
    }

    /**
     * @param {string} value 
     * @returns {void}
     */
    static getTitle() {
        return this.#title || this.#root
    }

    /**
     * @returns {string}
     */
    static getRootTitle() {
        return this.#root
    }

    /**
     * @returns {void}
     */
    static #updateTitle() {
        const document = this._getDocument()

        !this.getTitle() 
            ? (document.title = this.getRootTitle()) 
            : (document.title = this.getTitle()) 
    }
}

class View {
    constructor() {
        throw new Error(`${new.target.name} class must not be called with \"new\" keyword!`)
    }

    /**
     * @param {function} template 
     * @param {object} data 
     * @returns {string}
     */
    static render(template, data = {}) {
        if (typeof template !== "function") throw new InvalidArgumentTypeError("'template' must be a function!")

        try {
            return template(data)
        } catch (error) {
            console.error("Error during template rendering: ", error);            
        }
    }
}

class Router {
    static _window

    static _document

    static _routes = {};
    
    static _currentRoute = "";
    
    static _routePrefix = "";
    
    static _defaultRoute = {
        title : "404",
        template : () => "404 | Page not found!",
        middlewares : [],
        meta : {
            params : {},
            query : {}
        }
    }


    constructor() {
        throw new Error(`${new.target.name} class must not be called with \"new\" keyword!`)
    }

    /**
     * @param {object} params 
     */
    static configure({ window, document }) {
        if (!(window instanceof Window)) throw new InvalidArgumentTypeError("'window' must be a Window object")
                    
        if (!(document instanceof Document)) throw new InvalidArgumentTypeError("'document' must be a Document object")
        

        this._window = window

        this._document = document
    }

    /**
     * @param {string} target 
     * @returns {object}
     */
    static #findRoute(target) {
        for (const route in this._routes) {
            const regex = new RegExp(`^${route.replace(/\{(\w+)\}/g, '(?<$1>[^/{}]+)')}$`);
        
            if (!regex.test(target)) continue

            const { groups } = regex.exec(target)

            this.#setRouteQuery(route)

            this.#setRouteParams(route, groups)

            return this._routes[route]
        }
    }

    /**
     * 
     * @param {string} route 
     * @returns {boolean}
     */
    static #setRouteQuery(route) {
        const query = {}
        
        const { search } = location
        
        if (!search.length) return false


        search.slice(1).split("&").forEach(item => {
            const [key, value] = item.split("=")
        
            query[key] = value
        })

        this._routes[route]["meta"]["query"] = {...query}
    }

    /**
     * @param {string} route 
     * @param {object} params
     * @returns {void} 
     */
    static #setRouteParams(route, params) {
        this._routes[route]["meta"]["params"] = {...params}
    }

    /**
     * 
     * @param {string} route
     * @param {Window} window
     * @returns {void} 
     */
    static _setRouteToURL(route) {
        if (typeof route !== "string" || !route.startsWith("/")) throw new InvalidArgumentTypeError("'route' must be a string starting with \"/\"!")

        this._window.history.pushState({}, "", route)
    }

    /**
     * @param {string} route
     * @returns {void} 
     */
    static #injectTemplateToDOM(route) {
        try {
            const { title, template, middlewares, meta } = this.#findRoute(route) ?? this._defaultRoute

            Page.setTitle(title)
            
            this.#applyMiddlewares(middlewares)
            
            this._document.querySelector("#root").innerHTML = View.render(template, meta)
        } catch (error) {
            console.error("Error to inject route template:", route, error);
        }
    }

    /**
     * @returns {void}
     */
    static #activeHistroyNavigation() {
        this._window.addEventListener("popstate", event => {
            const route = event.target.location.pathname

            this.#injectTemplateToDOM(route)
        })
    }

    /**
     * @returns {void}
     */    
    static #changeRoutebyRequest() {
        const { pathname } = location

        this.#injectTemplateToDOM(pathname)
    }

    /**
     * @returns {void}
     */
    static #changeRoutebyLink() {
        Selector.findAll("a", this._document).each(anchor => {
            Element.onClick(anchor, (event) => {
                if (event.target.hasAttribute("data-link")) return
                
                event.preventDefault()

                const route = event.target.getAttribute("href")

                this._setRouteToURL(route)

                this.#injectTemplateToDOM(route)
            })
        })
    }

    /**
     * Executes middleware functions
     * @param {array} middlewares
     * @returns {void}
     */
    static #applyMiddlewares(middlewares) {
        try {
            middlewares.length && middlewares.forEach(middleware => middleware())
        } catch (error) {
            console.error("Error executing middleware:", error);
        }
    }

    /**
     * Initializes the router
     * @param {function} callback
     * @returns {void}
     */
    static run(callback = () => {}) {
        if (typeof callback !== "function") throw new InvalidArgumentTypeError("'callback' must be a function!")
        

        Page.setDocument(document)
        
        Page.setRootTitle(document.title)

        this.#activeHistroyNavigation()

        this.#changeRoutebyRequest()

        this.#changeRoutebyLink()

        callback()
    }
}

class Route extends Router {
    constructor() {
        throw new Error(`${new.target.name} class must not be called with \"new\" keyword!`)
    }

    /**
     * @param {string} route 
     * @param {fucntion} callback 
     * @returns {Route}
     */   
    static addRoute(route, callback) {
        if (typeof route !== "string") throw new InvalidArgumentTypeError("'route' must be a string!")
        
        if (typeof callback !== "function") throw new InvalidArgumentTypeError("'callback' must be a function!")


        this._routes[this._routePrefix + route] = {
            title : "",
            template: callback,
            middlewares: [],
            meta : {
                params: {},
                query: {},
            }
        };

        this._currentRoute = route;

        return this;
    }

    /**
     * @param {string} prefix 
     * @param {function} callback 
     * @returns {Route}
     */
    static group(prefix, callback) {
        if (typeof prefix !== "string" || !prefix.startsWith("/")) throw new InvalidArgumentTypeError("'prefix' must be a string!")
        
        if (typeof callback !== "function") throw new InvalidArgumentTypeError("'callback' must be a function!")


        const previousPrefix = this._routePrefix 

        this._routePrefix = prefix;

        callback();

        this._routePrefix = previousPrefix

        return this;
    }

    /**
     * @param {array} middlewares
     * @returns {void}
     */
    static middleware(middlewares) {
        if (!Array.isArray(middlewares)) throw new InvalidArgumentTypeError("'middlewares' must be an array!")

        const isDefinedRoutePrefix = this._routePrefix ? true : false

        // Add middlewares to single route
        if (!isDefinedRoutePrefix) {
            this._routes[this._routePrefix + this._currentRoute]["middlewares"].push(...middlewares);

            return;
        }

        // Add middlewares to the group of routes
        for (const route in this._routes) {
            if (!route.startsWith(this._routePrefix)) continue;

            this._routes[route]["middlewares"].push(...middlewares);
        }
    }

    /**
     * Set route page title
     * @param {string} value
     * @returns {void}
     */
    static title(value) {
        if (typeof value !== "string") throw new InvalidArgumentTypeError("'value' must be a string!")

        this._routes[this._routePrefix + this._currentRoute]["title"] = value
    }

    /**
     * @param {string} to - Route pointer  
     * @returns {string}
     */
    static redirect(to) {
        if (typeof to !== "string" || !to.startsWith("/")) throw new InvalidArgumentTypeError("'to' must be a string starting route with \"/\"!")


        this._setRouteToURL(to)

        const { template, meta } = this._routes[to] ?? this._defaultRoute;

        return View.render(template, meta)
    }
}


            Router.configure({ window, document })

            Route.addRoute("/", () => "Welcome Page");
            Route.addRoute("/products", () => "Products Page");
            Route.addRoute("/products/{id}", ({ params : { id } }) => `Product #${id} Page`);
            Route.addRoute("/courses/{tag}/{name}", () => "Products Page");
            Route.addRoute("/blog", () => Route.redirect("/test"));

            Router.run(() => {
                console.log("Router is running....");
            });
        </script>
    </body>
</html>